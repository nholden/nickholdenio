<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>One difference between SQLite and PostgreSQL revealed through continuous integration | Nick Holden dot IO</title>
    <link href="../../../../stylesheets/all.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <script src="../../../../javascripts/all.js" type="text/javascript"></script>

    <!-- Google Analytics //-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-64216632-1', 'auto');
      ga('send', 'pageview');
    </script>

  </head>

  <body class="blog blog_2015 blog_2015_07 blog_2015_07_23 blog_2015_07_23_one-difference-between-sqlite-and-postgresql-revealed-through-continuous-integration">
    <div class="hero"></div>
    <div class="headshot">
<a href="/">        <img src="/images/headshot.png" alt="Nick Holden" />
</a>    </div>
    <div class="content">
  <article>
    <div class="left-column"><h2>One difference between SQLite and PostgreSQL revealed through continuous integration</h2></div>
    <div class="right-column">
      <p>For a Rails application I'm working on, I use <a target="_blank" href="http://www.codeship.com">Codeship</a> for continuous integration. This means that whenever I make a new commit to my master branch and push it to Github, Codeship runs my entire test suite and pushes my application to production on Heroku if all the tests pass. This makes it easy to keep my production environment updated with my latest features, and it also catches bugs that don't appear in development.</p>

<p>One of the big differences between my development and production environments is that my application uses SQLite in development and PostgreSQL in production. Because of Active Record's magic, I don't notice this very often. However, a difference between SQLite and PostgreSQL caused this RSpec test on my User model that passed in development to fail when Codeship ran the test in production.</p>

<pre class="highlight ruby"><code><span class="n">it</span> <span class="s2">"should include users who are Facebook friends"</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="p">.</span><span class="nf">friends</span><span class="p">).</span><span class="nf">to</span> <span class="kp">include</span><span class="p">(</span><span class="vi">@friend_from_facebook</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>In this test, <code>@user</code> and <code>@friend_from_facebook</code> are users who are also friends on Facebook. When Codeship ran the test in production, I received an error.</p>

<pre class="highlight plaintext"><code>ActiveRecord::StatementInvalid:
  PG::UndefinedFunction: ERROR:  operator does not exist: character varying = bigint
  LINE 1: SELECT "users".* FROM "users"  WHERE ((uid IN (1234567890123...
                                                     ^
  HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
  : SELECT "users".* FROM "users"  WHERE ((uid IN (1234567890123456) AND provider = 'facebook') OR
                 (created_by_user_id = 88))
</code></pre>

<p>I took a look at the offending Active Record method call in my <code>User</code> model.</p>

<pre class="highlight ruby"><code><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"(uid IN (</span><span class="si">#{</span><span class="n">facebook_friends_uids</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">) AND provider = 'facebook') OR
                     (created_by_user_id = </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
</code></pre>

<p>When called on a user, the <code>friends</code> method is supposed to return an array of that user's friends. This call on Active Record's <code>where</code> method intended a user's friends to include both his Facebook friends and also the other users whom that user created. It generates a SQL query like this.</p>

<pre class="highlight sql"><code><span class="k">SELECT</span> <span class="nv">"users"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"users"</span>  <span class="k">WHERE</span> <span class="p">((</span><span class="n">uid</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1234567890123456</span><span class="p">)</span> <span class="k">AND</span> <span class="n">provider</span> <span class="o">=</span> <span class="s1">'facebook'</span><span class="p">)</span> <span class="k">OR</span> <span class="p">(</span><span class="n">created_by_user_id</span> <span class="o">=</span> <span class="mi">88</span><span class="p">))</span>
</code></pre>

<p>In the database schema, <code>uid</code> and <code>provider</code> are strings and <code>created_by_user_id</code> is an integer. As it turns out, omitting quotes around the <code>uid</code> in this SQL query does different things in SQLite and PostgreSQL.</p>

<p>In SQLite, <code>1234567890123456</code> is an <a target="_blank" href="https://www.sqlite.org/datatype3.html">integer</a>, which it automatically converts into a string when it receives the query. In PostgreSQL, the same number is a <a target="_blank" href="http://www.postgresql.org/docs/9.4/static/datatype-numeric.html">bigint</a>, which it does not convert into a string.</p>

<p>I added quotes around the <code>uid</code> in my Active Record method call so that it would pass a string in the SQL query rather than an integer or bigint.</p>

<pre class="highlight ruby"><code><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"(uid IN ('</span><span class="si">#{</span><span class="n">facebook_friends_uids</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">') AND provider = 'facebook') OR
                     (created_by_user_id = </span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
</code></pre>

<p>After the change, I made a new commit to my master branch and pushed it to Github. My test suite passed on Codeship, and Codeship automatically pushed my code to production.</p>

      <p><i>July 23, 2015</i></p>
    </div>
  </article>
</div>

    <div class="footer">
      <h2>Get in touch</h2>
      <a href="mailto:nick.r.holden@gmail.com"><i class="fa fa-envelope-o"></i> nick.r.holden@gmail.com</a><br />
      <a href="https://github.com/nholden" target="_blank"><i class="fa fa-github"></i> nholden</a><br />
      <a href="https://www.linkedin.com/in/nickholden" target="_blank"><i class="fa fa-linkedin-square"></i> Nick Holden</a><br />
      <a href="https://www.twitter.com/nickyholden" target="_blank"><i class="fa fa-twitter-square"></i> @NickyHolden</a>
    </div>
  </body>
</html>
